package theia.mitsuba

import theia._
import theia.mitsuba.Config._
import theia.Integrator
import theia.Sensor
import scala.util.Random
import java.io.File
import org.apache.commons.io.FileUtils
import scala.sys.process._
import com.github.tototoshi.csv._
import theia.MSR._
import breeze.linalg.DenseMatrix
import org.zeroturnaround.zip.ZipUtil
import st.sparse.sundry.ExistingDirectory
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths

object Render {
  def makeMitsubaScript(template: String, numChannels: Int, v: View): String = {
    assert(template.contains("$INTEGRATOR"))
    assert(template.contains("$SENSOR"))
    
    val sxi = implicitly[ShowXML[Integrator]]
    val sxsi = implicitly[ShowXML[(Sensor, Int)]]

    val replacedIntegrator = template.replace("$INTEGRATOR", sxi.show(v.integrator))
    replacedIntegrator.replace("$SENSOR", sxsi.show((v.sensor, numChannels)))
  }

  //  def makeSceneDirectory(modelDirectory: File, mitsubaScript: String): (File, File) = {
  //    val salt = Random.alphanumeric.take(8).mkString
  //
  //    val directory = new File("/tmp", modelDirectory.getPath.split("/").last + salt)
  //    println(s"Copying $modelDirectory to $directory")
  //    FileUtils.copyDirectory(modelDirectory, directory)
  //
  //    val scriptFile = new File(directory, "generated_scene.xml")
  //    println(s"Writing Mitsuba script to $scriptFile")
  //    FileUtils.writeStringToFile(scriptFile, mitsubaScript)
  //
  //    return (directory, scriptFile)
  //  }

  val workDirectory = {
    val d = new File("/tmp/theia")
    if (!d.isDirectory()) {
      d.mkdir()
    }
    ExistingDirectory(d)
  }

  def zip(directory: File): List[Byte] = {   
    val tf = File.createTempFile("directory_to_zip", ".zip", workDirectory)
    ZipUtil.pack(directory, tf)
    FileUtils.readFileToByteArray(tf).toList
  }

  def unzip(zippedDirectory: List[Byte], directory: File) {
    val tf = File.createTempFile("zip_to_directory", ".zip", workDirectory)
    FileUtils.writeByteArrayToFile(tf, zippedDirectory.toArray)
    ZipUtil.unpack(tf, directory)
  }

  def makeSceneDirectory(zippedDirectory: List[Byte]): File = {
    val td = new File(Files.createTempDirectory(Paths.get(workDirectory.getCanonicalPath), "scene").toString)
    unzip(zippedDirectory, td)
    td
  }
  
  def callShell(command: String) {
    println(s"Executing command line:\n$command")
    command !
  }

  def callMitsuba(scriptPath: File, outPath: File) {
    callShell(s"/usr/bin/mitsuba $scriptPath -o $outPath")
  }

  def makePythonScript(numChannels: Int, npyPath: File, csvPattern: (Int => File)): String = {
    val first = s"""
import numpy
arr = numpy.load("$npyPath")
if len(arr.shape) == 2:
  arr = numpy.reshape(arr, (arr.shape[0], arr.shape[1], 1))
"""
    def save(channel: Int): String = {
      val cpi = csvPattern(channel)
      s"""
numpy.savetxt("$cpi", arr[:, :, $channel], delimiter=",")
"""
    }

    (first :: (0 until numChannels).toList.map(save)).mkString("\n")
  }

  def loadCSVs(numChannels: Int, csvPattern: (Int => File)): List[List[List[Double]]] = {
    for (c <- (0 until numChannels).toList) yield {
      val reader = CSVReader.open(csvPattern(c))
      reader.all.map(_.map(_.toDouble))
    }
  }

  def parseRenderingComponent(numChannels: Int, csv: List[List[List[Double]]]): Either[Matrix1, Matrix3] = {
    assert(numChannels == 1 || numChannels == 3)
    assert(csv.size == numChannels)
    assert(csv(0).size > 0)
    assert(csv(0)(0).size > 0)

    val numRows = csv(0).size
    val numColumns = csv(0)(0).size

    if (numChannels == 1) {
      Left(DenseMatrix.tabulate[Double](numRows, numColumns) {
        case (r, c) => csv(0)(r)(c)
      })
    } else {
      Right(DenseMatrix.tabulate[(Double, Double, Double)](numRows, numColumns) {
        case (r, c) => (csv(0)(r)(c), csv(1)(r)(c), csv(2)(r)(c))
      })
    }
  }

  def renderComponent(m: Model, v: View): Either[Matrix1, Matrix3] = {
    println(s"Rendering component: $v.integrator")
    
    val sd = makeSceneDirectory(m.zippedDirectory)
    val template = FileUtils.readFileToString(new File(sd, m.sceneTemplatePath))

    val numChannels = v.integrator match {
      case RGB      => 3
      case Position => 3
      case Depth    => 1
    }

    val ms = makeMitsubaScript(template, numChannels, v)
    val mitsubaScriptPath = new File(sd, "autogenerated_scene.xml")
    FileUtils.writeStringToFile(mitsubaScriptPath, ms)
    val npyPath = new File(sd, "render.npy")

    callMitsuba(mitsubaScriptPath, npyPath)

    def csvPattern(channel: Int): File = new File(sd, s"render_$channel.csv")

    val ps = makePythonScript(numChannels, npyPath, csvPattern)
    val pythonScriptPath = new File(sd, "npy_to_csvs.py")
    FileUtils.writeStringToFile(pythonScriptPath, ps)

    callShell(s"/usr/bin/python $pythonScriptPath")
    
    val csvs = loadCSVs(numChannels, csvPattern)
    parseRenderingComponent(numChannels, csvs)
  }
  
  def render: Renderer = (m, s) => {
    println("Rendering all 3 components")
    
    val rgb = renderComponent(m, View(RGB, s)).right.get
    val p = renderComponent(m, View(Position, s)).right.get
    val d = renderComponent(m, View(Depth, s)).left.get
    
    Rendering(RGBImage(rgb), PositionMap(p), DepthMap(d))
  }
}



